<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Servo - Live TV</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/user/live-tv.css">
    <style>
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #ddd;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 60vh;
            flex-direction: column;
            gap: 20px;
        }
        .error-message {
            background: #fee;
            color: #c00;
            padding: 12px 16px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        {% include 'user/components/sidebar.html' %}

        <!-- Main Content -->
        <main class="main-content">
            <div class="content-wrapper">
                <!-- Categories Sidebar -->
                <aside class="categories-sidebar">
                    <h2 class="categories-title">ğŸ“º Categories</h2>
                    <div class="categories-list" id="categoriesList">
                        <div class="loading-spinner"></div>
                    </div>
                </aside>

                <!-- Channels Grid -->
                <section class="channels-section">
                    <div class="channels-header">
                        <h1 class="channels-title" id="channelsTitle">All Channels</h1>
                        <span class="channels-count" id="channelsCount">Loading...</span>
                    </div>

                    <div class="channels-grid" id="channelsGrid">
                        <div class="loading-container">
                            <div class="loading-spinner"></div>
                            <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª...</p>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <script>
        /**
         * ğŸ“º Live TV - Dynamic Channel Loader
         * ÙŠØ­Ù…Ù„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ù…Ù† M3U ÙˆØ¹Ø±Ø¶Ù‡Ø§ Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø§Øª
         */
        
        class LiveTVController {
            constructor() {
                this.channels = [];
                this.categories = new Map();
                this.favorites = this.loadFavorites();
                this.currentCategory = 'all';
                this.streamingManager = null;
            }

            /**
             * Ø§Ù„Ø¨Ø¯Ø¡ ÙˆØ§Ù„ØªÙ‡ÙŠØ¦Ø©
             */
            async init() {
                console.log('ğŸ“º Ø¨Ø¯Ø¡ ØªÙ‡ÙŠØ¦Ø© Live TV...');
                
                try {
                    // ØªÙ‡ÙŠØ¦Ø© Ù…Ø¯ÙŠØ± Ø§Ù„Ø¨Ø«
                    this.streamingManager = new StreamingManager();
                    await this.streamingManager.init();
                    
                    // Ø¬Ù„Ø¨ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ù…Ù† IPTV
                    this.channels = this.streamingManager.getContentByType('live-tv');
                    
                    console.log(`âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ ${this.channels.length} Ù‚Ù†Ø§Ø©`);
                    
                    // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¦Ø§Øª
                    this.groupChannels();
                    
                    // Ø¹Ø±Ø¶ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
                    this.renderCategories();
                    this.renderChannels();
                    this.setupEventListeners();
                    
                } catch (error) {
                    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©:', error);
                    this.showError('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù†Ø´Ø·.');
                }
            }

            /**
             * ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©
             */
            groupChannels() {
                this.categories.clear();
                
                this.channels.forEach(channel => {
                    const category = channel.group || 'Other';
                    
                    if (!this.categories.has(category)) {
                        this.categories.set(category, []);
                    }
                    
                    this.categories.get(category).push(channel);
                });
            }

            /**
             * Ø¹Ø±Ø¶ Ø§Ù„ÙØ¦Ø§Øª
             */
            renderCategories() {
                const categoriesList = document.getElementById('categoriesList');
                if (!categoriesList) return;
                
                let html = `
                    <button class="category-item active" data-category="all">
                        <span>Ø§Ù„ÙƒÙ„</span>
                        <span class="count">(${this.channels.length})</span>
                    </button>
                    <button class="category-item" data-category="favorites">
                        <span>â™¡ Ø§Ù„Ù…ÙØ¶Ù„Ø©</span>
                        <span class="count">(${this.favorites.length})</span>
                    </button>
                `;
                
                // Ø¥Ø¶Ø§ÙØ© ÙƒÙ„ ÙØ¦Ø©
                this.categories.forEach((channels, category) => {
                    html += `
                        <button class="category-item" data-category="${category}">
                            <span>${category}</span>
                            <span class="count">(${channels.length})</span>
                        </button>
                    `;
                });
                
                categoriesList.innerHTML = html;
            }

            /**
             * Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†ÙˆØ§Øª
             */
            renderChannels() {
                const channelsGrid = document.getElementById('channelsGrid');
                const channelsCount = document.getElementById('channelsCount');
                const channelsTitle = document.getElementById('channelsTitle');
                
                if (!channelsGrid) return;
                
                // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø±Ø§Ø¯ Ø¹Ø±Ø¶Ù‡Ø§
                let channelsToShow = [];
                let titleText = 'Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª';
                
                if (this.currentCategory === 'all') {
                    channelsToShow = [...this.channels];
                    titleText = 'Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª';
                } else if (this.currentCategory === 'favorites') {
                    channelsToShow = this.channels.filter(ch => this.isFavorite(ch.id));
                    titleText = 'Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…ÙØ¶Ù„Ø©';
                } else {
                    channelsToShow = this.categories.get(this.currentCategory) || [];
                    titleText = this.currentCategory;
                }
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„Ø¹Ø¯Ø¯
                channelsTitle.textContent = titleText;
                channelsCount.textContent = `${channelsToShow.length} Ù‚Ù†Ø§Ø©`;
                
                // Ø¥Ø°Ø§ Ù„Ù… ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª
                if (channelsToShow.length === 0) {
                    channelsGrid.innerHTML = `
                        <div class="empty-state">
                            <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©</p>
                        </div>
                    `;
                    return;
                }
                
                // Ø¨Ù†Ø§Ø¡ HTML Ù„Ù„Ù‚Ù†ÙˆØ§Øª
                let html = '';
                
                channelsToShow.forEach((channel, index) => {
                    const isFavorite = this.isFavorite(channel.id);
                    const logo = channel.logo || `https://via.placeholder.com/100x100?text=${encodeURIComponent(channel.name)}`;
                    
                    html += `
                        <div class="channel-card" data-channel-id="${channel.id}" data-index="${index}">
                            <div class="channel-thumbnail">
                                <img 
                                    src="${logo}" 
                                    alt="${channel.name}"
                                    onerror="this.src='https://via.placeholder.com/100x100?text=Channel'"
                                >
                                <div class="play-overlay">
                                    <button class="play-btn" title="ØªØ´ØºÙŠÙ„">
                                        <svg viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M8 5v14l11-7z"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="channel-info">
                                <h3 class="channel-name">${channel.name}</h3>
                                <div class="channel-meta">
                                    <span class="channel-quality">HD</span>
                                    <span class="channel-category">${channel.group}</span>
                                </div>
                            </div>
                            <button class="channel-favorite ${isFavorite ? 'active' : ''}" data-channel-id="${channel.id}" title="${isFavorite ? 'Ø­Ø°Ù Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©' : 'Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…ÙØ¶Ù„Ø©'}">
                                <svg viewBox="0 0 24 24" fill="${isFavorite ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
                                    <path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"></path>
                                </svg>
                            </button>
                        </div>
                    `;
                });
                
                channelsGrid.innerHTML = html;
                
                // Ø¥Ø¶Ø§ÙØ© Event Listeners
                this.attachListeners();
            }

            /**
             * Ø¥Ø¶Ø§ÙØ© Event Listeners
             */
            attachListeners() {
                // Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†Ø§Ø©
                document.querySelectorAll('.channel-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        if (!e.target.closest('.channel-favorite')) {
                            const channelId = card.dataset.channelId;
                            const channel = this.channels.find(ch => ch.id === channelId);
                            if (channel) {
                                this.playChannel(channel);
                            }
                        }
                    });
                });
                
                // Ø²Ø± Ø§Ù„Ù…ÙØ¶Ù„Ø©
                document.querySelectorAll('.channel-favorite').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const channelId = btn.dataset.channelId;
                        this.toggleFavorite(channelId);
                    });
                });
            }

            /**
             * Ø¥Ø¹Ø¯Ø§Ø¯ Event Listeners Ù„Ù„ÙØ¦Ø§Øª
             */
            setupEventListeners() {
                document.querySelectorAll('.category-item').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const category = e.target.closest('.category-item').dataset.category;
                        this.selectCategory(category);
                    });
                });
            }

            /**
             * Ø§Ø®ØªÙŠØ§Ø± ÙØ¦Ø©
             */
            selectCategory(category) {
                this.currentCategory = category;
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø²Ø±Ø§Ø±
                document.querySelectorAll('.category-item').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-category="${category}"]`)?.classList.add('active');
                
                // Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†ÙˆØ§Øª
                this.renderChannels();
            }

            /**
             * ØªØ´ØºÙŠÙ„ Ù‚Ù†Ø§Ø©
             */
            async playChannel(channel) {
                try {
                    console.log('â–¶ï¸ ØªØ´ØºÙŠÙ„:', channel.name);
                    
                    // ÙØªØ­ player
                    this.openPlayer(channel);
                    
                    // ØªØ´ØºÙŠÙ„ Ù…Ù† StreamingManager
                    await this.streamingManager.playContent(channel);
                    
                    console.log('âœ… Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„');
                    
                } catch (error) {
                    console.error('âŒ Ø®Ø·Ø£:', error);
                    this.showError('ÙØ´Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø©');
                }
            }

            /**
             * ÙØªØ­ Ù…Ø´ØºÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
             */
            openPlayer(channel) {
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† player Ù…ÙˆØ¬ÙˆØ¯
                let playerDiv = document.getElementById('player-modal');
                if (playerDiv) playerDiv.remove();
                
                // Ø¥Ù†Ø´Ø§Ø¡ player Ø¬Ø¯ÙŠØ¯
                playerDiv = document.createElement('div');
                playerDiv.id = 'player-modal';
                playerDiv.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                `;
                
                playerDiv.innerHTML = `
                    <div style="position: relative; width: 90%; height: 90%; background: #000; border-radius: 8px; overflow: hidden;">
                        <button style="position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: rgba(0,0,0,0.7); border: none; color: white; font-size: 20px; cursor: pointer; border-radius: 50%; z-index: 10000;" onclick="this.closest('#player-modal').remove()">âœ•</button>
                        <video id="video-player" controls autoplay style="width: 100%; height: 100%; background: #000;"></video>
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.9)); padding: 20px; color: white;">
                            <h2 style="margin: 0 0 5px 0;">${channel.name}</h2>
                            <p style="margin: 0; opacity: 0.7;">${channel.group}</p>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(playerDiv);
            }

            /**
             * Ø¥Ø¶Ø§ÙØ©/Ø­Ø°Ù Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©
             */
            toggleFavorite(channelId) {
                const index = this.favorites.indexOf(channelId);
                
                if (index > -1) {
                    this.favorites.splice(index, 1);
                } else {
                    this.favorites.push(channelId);
                }
                
                this.saveFavorites();
                this.renderChannels();
            }

            /**
             * Ù‡Ù„ Ø§Ù„Ù‚Ù†Ø§Ø© Ù…ÙØ¶Ù„Ø©
             */
            isFavorite(channelId) {
                return this.favorites.includes(channelId);
            }

            /**
             * Ø­ÙØ¸ Ø§Ù„Ù…ÙØ¶Ù„Ø©
             */
            saveFavorites() {
                localStorage.setItem('livetv_favorites', JSON.stringify(this.favorites));
            }

            /**
             * ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙØ¶Ù„Ø©
             */
            loadFavorites() {
                const saved = localStorage.getItem('livetv_favorites');
                return saved ? JSON.parse(saved) : [];
            }

            /**
             * Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
             */
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = `âŒ ${message}`;
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #fee;
                    color: #c00;
                    padding: 12px 20px;
                    border-radius: 4px;
                    z-index: 10000;
                    font-weight: 600;
                `;
                
                document.body.appendChild(errorDiv);
                setTimeout(() => errorDiv.remove(), 4000);
            }
        }

        // ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        document.addEventListener('DOMContentLoaded', () => {
            const app = new LiveTVApp();
        });

        // ============================================
        // Legacy Event Handlers (for compatibility)
        // ============================================

        function handleNavigation(event) {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');
        }

        function handleLogout() {
            console.log('ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬...');
            window.location.href = '/logout';
        }

        // Focus Navigation for TV Remote
        document.addEventListener('keydown', (event) => {
            const focusedElement = document.activeElement;

            switch (event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    moveFocus('up');
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    moveFocus('down');
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    moveFocus('left');
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    moveFocus('right');
                    break;
                case 'Enter':
                    if (focusedElement && focusedElement.click) {
                        focusedElement.click();
                    }
                    break;
            }
        });

        function moveFocus(direction) {
            const focusableElements = Array.from(
                document.querySelectorAll('button, [href], input, [tabindex]')
            ).filter(el => el.offsetHeight > 0 && el.offsetWidth > 0);

            const currentIndex = focusableElements.indexOf(document.activeElement);
            let nextIndex = currentIndex === -1 ? 0 : currentIndex;

            switch (direction) {
                case 'up':
                    nextIndex = currentIndex > 0 ? currentIndex - 1 : focusableElements.length - 1;
                    break;
                case 'down':
                    nextIndex = currentIndex < focusableElements.length - 1 ? currentIndex + 1 : 0;
                    break;
                case 'left':
                    nextIndex = currentIndex > 0 ? currentIndex - 1 : focusableElements.length - 1;
                    break;
                case 'right':
                    nextIndex = currentIndex < focusableElements.length - 1 ? currentIndex + 1 : 0;
                    break;
            }

            focusableElements[nextIndex]?.focus();
        }
    </script>
    
    <!-- HLS.js for HLS/M3U8 streaming support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    
    <script>
        // Simple Live TV Player
        let channels = [];
        let hls = null;
        const streamingManager = window.streamingManager || {};

        async function initLiveTV() {
            try {
                // Get token and playlist
                const tokenResp = await fetch('/api/stream/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({})
                });

                const tokenData = await tokenResp.json();
                
                // Fetch playlist
                const playlistResp = await fetch(tokenData.playlist_url);
                const playlistText = await playlistResp.text();
                
                // Parse M3U
                const lines = playlistText.split('\n');
                const channelsMap = new Map();
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].startsWith('#EXTINF')) {
                        const name = lines[i].match(/,(.+)$/)?.[1]?.trim() || 'Unknown';
                        const logo = lines[i].match(/tvg-logo="([^"]*)"/)?.[1] || '';
                        const group = lines[i].match(/group-title="([^"]+)"/)?.[1] || 'Other';
                        const url = lines[i + 1]?.trim();
                        
                        if (url && url.startsWith('http')) {
                            channels.push({ id: name.replace(/\s+/g, '_'), name, logo, group, url, type: 'live-tv' });
                            
                            // Group by category
                            if (!channelsMap.has(group)) {
                                channelsMap.set(group, []);
                            }
                            channelsMap.get(group).push(channels[channels.length - 1]);
                        }
                    }
                }

                // Render categories
                const categoriesList = document.getElementById('categoriesList');
                categoriesList.innerHTML = `
                    <button class="category-item active" onclick="filterCategory('all')">
                        <span>Ø§Ù„ÙƒÙ„</span>
                        <span class="count">(${channels.length})</span>
                    </button>
                    <button class="category-item" onclick="filterCategory('favorites')">
                        <span>â™¡ Ø§Ù„Ù…ÙØ¶Ù„Ø©</span>
                        <span class="count">(0)</span>
                    </button>
                `;
                
                for (const [group, items] of channelsMap) {
                    categoriesList.innerHTML += `
                        <button class="category-item" onclick="filterCategory('${group}')">
                            <span>${group}</span>
                            <span class="count">(${items.length})</span>
                        </button>
                    `;
                }

                // Render all channels
                filterCategory('all');

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('channelsGrid').innerHTML = '<div class="error-message">Failed to load channels</div>';
            }
        }

        function filterCategory(category) {
            const channelsGrid = document.getElementById('channelsGrid');
            const channelsTitle = document.getElementById('channelsTitle');
            const channelsCount = document.getElementById('channelsCount');
            
            let filtered = channels;
            let title = 'Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª';

            if (category !== 'all') {
                filtered = channels.filter(ch => ch.group === category);
                title = category;
            }

            channelsTitle.textContent = title;
            channelsCount.textContent = `${filtered.length} Ù‚Ù†Ø§Ø©`;

            channelsGrid.innerHTML = filtered.map((ch, idx) => `
                <div class="channel-card" onclick="playChannel('${ch.url}', '${ch.name}')">
                    <div class="channel-thumbnail">
                        <img src="${ch.logo}" alt="${ch.name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23333%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2214%22%3E${encodeURIComponent(ch.name.substring(0,3))}%3C/text%3E%3C/svg%3E'">
                        <div class="play-overlay">
                            <button class="play-btn" title="Play">â–¶</button>
                        </div>
                    </div>
                    <div class="channel-info">
                        <h3 class="channel-name">${ch.name}</h3>
                        <div class="channel-meta">
                            <span class="channel-quality">HD</span>
                            <span class="channel-category">${ch.group}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function playChannel(url, name) {
            // ğŸ¬ Step 1: Ø§Ø·Ù„Ø¨ play token Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±
            fetch('/api/stream/play', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    stream_url: url,
                    content_id: name.replace(/\s+/g, '_'),
                    content_name: name
                })
            }).then(r => r.json()).then(data => {
                if (data.success && data.play_token) {
                    // ğŸ¬ Step 2: Ø§Ø·Ù„Ø¨ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ù† /stream/live Ù…Ø¹ Ø§Ù„ØªÙˆÙƒÙ†
                    fetch(`/stream/live?token=${data.play_token}`)
                        .then(r => r.json())
                        .then(streamData => {
                            if (streamData.success && streamData.play_url) {
                                // Open player in modal with authorized URL
                                const modal = document.createElement('div');
                                modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:9999;display:flex;align-items:center;justify-content:center';
                                
                                const videoHtml = `
                                    <div style="position:relative;width:90%;height:90%;background:#000;border-radius:8px">
                                        <button onclick="this.closest('div').parentElement.remove()" style="position:absolute;top:10px;right:10px;width:40px;height:40px;background:rgba(0,0,0,0.7);border:none;color:white;font-size:20px;cursor:pointer;border-radius:50%;z-index:10000">âœ•</button>
                                        <video id="modal-video" style="width:100%;height:100%;background:#000" controls autoplay></video>
                                    </div>
                                `;
                                modal.innerHTML = videoHtml;
                                document.body.appendChild(modal);

                                // Play stream
                                const video = modal.querySelector('#modal-video');
                                playStream(streamData.play_url, video);
                            } else {
                                alert('Ø®Ø·Ø£: ' + (streamData.error || 'ÙØ´Ù„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨Ø«'));
                            }
                        })
                        .catch(err => alert('Ø®Ø·Ø£: ' + err.message));
                } else {
                    alert('Ø®Ø·Ø£: ' + (data.message || 'ÙØ´Ù„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙˆÙƒÙ† Ø§Ù„ØªØ´ØºÙŠÙ„'));
                }
            }).catch(err => alert('Error: ' + err.message));
        }

        function playStream(streamUrl, videoElement) {
            if (hls) {
                hls.destroy();
            }

            if (Hls.isSupported()) {
                hls = new Hls();
                hls.loadSource(streamUrl);
                hls.attachMedia(videoElement);
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    videoElement.play();
                });
            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                videoElement.src = streamUrl;
                videoElement.play();
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', initLiveTV);
    </script>
</body>
</html>
